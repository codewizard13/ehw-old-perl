#!/usr/bin/perl
#
# Program:    eh_sortFilesByExtension_051306_01.pl
# Creator:    Eric Hepperle
# Date:       05/14/06
#
# Purpose:    Sort contents of a user specified folder
#             by file extension.  Subfolders will have
#             names like "Documents", "Audio", "Video",
#             etc.
#
############################################################


############################################################
##################   INCLUDED MODULES:   ###################
############################################################

use Cwd; # cwd = current working directory
use File::Copy;


############################################################
#################   MAIN CONTROL PROGRAM:   ################
############################################################

# Initialize Variables:
&init_variables;

# TRACING: Display directory this program is in
print "\t\$start_dir = $start_dir\n\n";

# Get Sourc Directory From User
print "Enter full path to directory containing files to sort\n";
print "(EX:  C:/Program Files/Microsoft)\n\n";
$ans = <STDIN>;  # store standard input in a generic scalar
chomp($ans);
# TRACING: display value of $ans
print "\n\t\$ans = $ans\n\n";

# store source path
$source_folder = $ans;

# Open Source Directory, list directory contents, and save
#    list for later.  Name of array stored is:
#    @dir_entries
&dir_listing($source_folder);

# TRACING: Display the result stored in @dir_entries array
print (@dir_entries);
print "\n\n\n";

# TRACING: Display result of &print_array_list sub
#    (Should be same as previous trace.)
&print_array_list(@dir_entries);
print "\n\n\n";

# TRACING: Display result of $get_ext sub
$test_filename = "biteme and jack me off - get some!!!.avi";
print "\tTesting \&get_ext sub .................................\n\n";
&get_ext($test_filename);

# TRACING: Display elements of test file
@testfile_parts = split(/\./, $test_file_01);
print "\tprinting parts of the \$test_file_01 with &print_array_list sub ............\n\n";
&print_array_list(@testfile_parts);

# Define Destination Directory
#
# get dest dir from user
print "Enter the full path to the destination directory\n";
$ans = <STDIN>;
chomp($ans);
$dest_dir = $ans;

# define directory structure, returns @subdirs
&define_directories($dest_dir, audio, video, docs, apps, pix);

# Make directory structures
&build_directory_structure(@fqdir_list);

# sort all files and move to appropriate dir
&sort_and_move_files(@dir_entries);

$pause; # Press any key to end program.


############################################################
#####################   SUBROUTINES:   #####################
############################################################

# 1) READ EACH FILE IN A DIRECTORY
#
#   A) Open source directory
#   B) Read each filename into an array
#   C) For each filename, get the 8.3 extension
#     1. Make sure to account for filenames that
#        include more than one "."
#   D) Sort each file into an appropriate folder
#     1. Ex: Audio, Video, Document, etc ...

sub init_variables {
   # initialize all variables here
   $pause = <STDIN>; # Displays "Press any key to continue ..."
   $start_dir = cwd;
   $source_folder = "";
   $test_file_01 = "jenny.sucks.my.cock.now - 045067_01.34 - monkey ass.mpeg";
}

sub dir_listing {
   # get argument (directory to read)
   my ($dir_to_read) = shift(@_);

   # open directory and display msg if error as follows:
   # "ERROR: Some error generated by OS goes here"
   opendir(SOURCE, $dir_to_read) || error("ERROR: $!\n");

      # store all files in an array, sorted
      #    alphabetically ascending (0-9a-z)
      @dir_entries = sort(readdir(SOURCE));

   closedir(SOURCE);
}

# Prints elements of an array, each element on its own line.
sub print_array_list {
   #get argument: array name
   my (@arr) = @_;
   # TRACING: Print name of argument passed
   print "\targument passed:\n\n@arr";
   print "\n\n";
  
   my $count = 1;
   my $el; # define local element var
   foreach $el (@arr) {
      # Use this to print filenames with line count:
      print "$count) $el\n";
      # print "$el\n"; # print only
      $count++;
   }
   print "\n\n";
}

# Gets file extension by parsing
#    (Takes 1 filename argument.)
#
sub get_ext {
   # get filename argument.
   # (NOTE: parens are required around the variable
   #    preceded by 'my', or a number will be returned
   #    instead of the filename.)
   my ($file_name) = @_;
   
   # TRACING: Display the value of filename passed.
   print "\t\n\n\$file_name = $file_name\n\n\n";
   
   # split filename
   # (NOTE: to separate by a "." you must use "\.";
   #     the period has to be escaped or it won't work.)
   @filename_parts = split(/\./, $file_name);

   # TRACING: Display elements of $file_name
   print "\t(Tracing within sub)\n";
   print "\tprinting parts of \$file_name with &print_array_list sub ............\n\n";
   &print_array_list(@filename_parts);
   
   # TRACING: Display array length
   $array_length = $#filename_parts;
   print "Length of array = $array_length\n\n";
   # CAUTION!: I have a feeling this could be a problem later on.
   print "Number of elements in array = ", $array_length + 1, "\n\n";
   
   # Get last element of array
   $last_element = $filename_parts[$array_length];
   # TRACING: Display the last element of the array
   print "\t\$last_element = $last_element\n\n";
   
   # define extension
   $ext = $last_element;
   
}

# Define directory structure
sub define_directories {
   # define rest of the arguments as a separate array
   # (NOTE:  Could use "splice (@array, offset, length);"
   #    here, but since only 1st value is being removed,
   #    makes more sense to use shift/unshift)
   $arg_00 = shift(@_);
   print "\$arg_00 = $arg_00\n\n";
   $dest_dir = $arg_00;

   # assign rest of arguments to new array
   @restdirs = @_;
   
   # clear @fqdir_list
   @fqdir_list = ($dest_dir);
   
   # create full path from @restdirs
   foreach $dir (@restdirs) {
      $this_dir = "$dest_dir/$dir";
      @fqdir_list = (@fqdir_list, $this_dir);
   }
   
   
   
   # TRACING: Print out elements of @subdirs
   &print_array_list(@fqdir_list);  
}

sub make_dir {
   # define directory as first argument passed
   my ($dir_to_make) = shift(@_);
   
   # check if dir exists
   if (-d $dir_to_make) {
      print "Directory [$dir_to_make] EXISTS!\n\n";
   } else {
      print "Creating directory [$dir_to_make] ...\n\n";
      mkdir("$dir_to_make") || die "could not create dir $dir_to_make : $!";
      
      # check if dir exists; if was created successfully, will exist now.
      if (-d $dir_to_make) {
         print "Directory created successfully!\n\n";
      }
   }
}

# define directory structure
sub build_directory_structure {
   my (@directories) = @_;
   
   foreach $el (@directories) {
      &make_dir($el);
   }
}


# sort and move files by extension
# (NOTE: Don't forget to use "eq" not "="
#    when comparing strings.)
sub sort_and_move_files {

   # Arguments passed should be files to process;
   #    store them in an array.
   my (@files) = @_;

   print "\n\n";
   
   foreach $file (@files) {
      
      # get this file's extension.
      $file_ext = &get_ext($file);
      #
      # TRACING: Display variable values
      print "\tFilename: $file\n";
      print "\tExtension: $file_ext\n\n";
      
      if ($file_ext eq "avi") {
         print "Moving [$source_folder/$file] to  [$dest_dir/video/$file] ...\n\n";
         move("$source_folder/$file", "$dest_dir/video/$file");
      }
      if ($file_ext eq "jpg") {
         print "Moving [$source_folder/$file] to  [$dest_dir/pix/$file] ...\n\n";
         move("$source_folder/$file", "$dest_dir/pix/$file");
      }
      if ($file_ext eq "txt") {
         print "Moving [$source_folder/$file] to  [$dest_dir/docs/$file] ...\n\n";
         move("$source_folder/$file", "$dest_dir/docs/$file");
      }
      if ($file_ext eq "mp3") {
         print "Moving [$source_folder/$file] to  [$dest_dir/audio/$file] ...\n\n";
         move("$source_folder/$file", "$dest_dir/audio/$file");
      }
      
      # reset file extension
      $file_ext eq "";
 
   }
}

1; # used to be compatible with "require" statements.